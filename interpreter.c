/*
** Lua-Allegro interpreter
** See Copyright Notice in lua.h
*/

#define lua_c

#include "lprefix.h"

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "lua.h"
#include "lauxlib.h"
#include "lualib.h"

#include <allegro.h>
#include "wrapper.h"

#define LUA_PROGNAME	"lua-allegro"
#define LUA_SCRIPTNAME	"main.lua"

static lua_State *globalL = NULL;

static const char *progname = LUA_PROGNAME;
static const char *scriptname = LUA_SCRIPTNAME;

/*
** Hook set by signal function to stop the interpreter.
*/
static void lstop (lua_State *L, lua_Debug *ar) {
  (void)ar;  /* unused arg. */
  lua_sethook(L, NULL, 0, 0);  /* reset hook */
  luaL_error(L, "interrupted!");
}


/*
** Function to be called at a C signal. Because a C signal cannot
** just change a Lua state (as there is no proper synchronization),
** this function only sets a hook that, when called, will stop the
** interpreter.
*/
static void laction (int i) {
  signal(i, SIG_DFL); /* if another SIGINT happens, terminate process */
  lua_sethook(globalL, lstop, LUA_MASKCALL | LUA_MASKRET | LUA_MASKCOUNT, 1);
}


/*
** Prints an error message, adding the program name in front of it
** (if present)
*/
static void l_message (const char *pname, const char *msg) {
  if (pname) lua_writestringerror("%s: ", pname);
  lua_writestringerror("%s\n", msg);
}


/*
** Check whether 'status' is not OK and, if so, prints the error
** message on the top of the stack. It assumes that the error object
** is a string, as it was either generated by Lua or by 'msghandler'.
*/
static int report (lua_State *L, int status) {
  if (status != LUA_OK) {
    const char *msg = lua_tostring(L, -1);
    l_message(progname, msg);
    lua_pop(L, 1);  /* remove message */
  }
  return status;
}


/*
** Message handler used to run all chunks
*/
static int msghandler (lua_State *L) {
  const char *msg = lua_tostring(L, 1);
  if (msg == NULL) {  /* is error object not a string? */
    if (luaL_callmeta(L, 1, "__tostring") &&  /* does it have a metamethod */
        lua_type(L, -1) == LUA_TSTRING)  /* that produces a string? */
      return 1;  /* that is the message */
    else
      msg = lua_pushfstring(L, "(error object is a %s value)",
                               luaL_typename(L, 1));
  }
  luaL_traceback(L, L, msg, 1);  /* append a standard traceback */
  return 1;  /* return the traceback */
}


/*
** Interface to 'lua_pcall', which sets appropriate message function
** and C-signal handler. Used to run all chunks.
*/
static int docall (lua_State *L, int narg, int nres) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, msghandler);  /* push message handler */
  lua_insert(L, base);  /* put it under function and args */
  globalL = L;  /* to be available to 'laction' */
  signal(SIGINT, laction);  /* set C-signal handler */
  status = lua_pcall(L, narg, nres, base);
  signal(SIGINT, SIG_DFL); /* reset C-signal handler */
  lua_remove(L, base);  /* remove message handler from the stack */
  return status;
}

/*
** Create the 'arg' table, which stores all arguments from the
** command line ('argv'). It should be aligned so that, at index 0,
** it has 'argv[script]', which is the script name. The arguments
** to the script (everything after 'script') go to positive indices;
** other arguments (before the script name) go to negative indices.
** If there is no script name, assume interpreter's name as base.
*/
static void createargtable (lua_State *L, char **argv, int argc, int script) {
  int i, narg;
  if (script == argc) script = 0;  /* no script name? */
  narg = argc - (script + 1);  /* number of positive indices */
  lua_createtable(L, narg, script + 1);
  for (i = 0; i < argc; i++) {
    lua_pushstring(L, argv[i]);
    lua_rawseti(L, -2, i - script);
  }
  lua_setglobal(L, "arg");
}


/*
** 
** Create the 'allegro' table, defined in wrapper.c
*/

static void createAllegrotable (lua_State *L) {
	lua_createtable(L, TABLESIZE, 0);	
	for( int i = 0; i < TABLESIZE; i++ ) {
		lua_pushstring(L, nametable[i]);
		lua_pushcfunction(L, functable[i]);
		lua_rawset(L, -3);
	}
	lua_setglobal(L, "allegro");
}


static int dochunk (lua_State *L, int status) {
  if (status == LUA_OK) status = docall(L, 0, 0);
  return report(L, status);
}


static int dofile (lua_State *L, const char *name) {
  return dochunk(L, luaL_loadfile(L, name));
}

static int dostring (lua_State *L, const char *s, const char *name) {
  return dochunk(L, luaL_loadbuffer(L, s, strlen(s), name));
}

#if 0
/*
** Calls 'require(name)' and stores the result in a global variable
** with the given name.
*/
static int dolibrary (lua_State *L, const char *name) {
  int status;
  lua_getglobal(L, "require");
  lua_pushstring(L, name);
  status = docall(L, 1, 1);  /* call 'require(name)' */
  if (status == LUA_OK)
    lua_setglobal(L, name);  /* global[name] = require return */
  return report(L, status);
}


/* mark in error messages for incomplete statements */
#define EOFMARK		"<eof>"
#define marklen		(sizeof(EOFMARK)/sizeof(char) - 1)


/*
** Check whether 'status' signals a syntax error and the error
** message at the top of the stack ends with the above mark for
** incomplete statements.
*/
static int incomplete (lua_State *L, int status) {
  if (status == LUA_ERRSYNTAX) {
    size_t lmsg;
    const char *msg = lua_tolstring(L, -1, &lmsg);
    if (lmsg >= marklen && strcmp(msg + lmsg - marklen, EOFMARK) == 0) {
      lua_pop(L, 1);
      return 1;
    }
  }
  return 0;  /* else... */
}

#endif

/*
** Prints (calling the Lua 'print' function) any values on the stack
*/
static void l_print (lua_State *L) {
  int n = lua_gettop(L);
  if (n > 0) {  /* any result to be printed? */
    luaL_checkstack(L, LUA_MINSTACK, "too many results to print");
    lua_getglobal(L, "print");
    lua_insert(L, 1);
    if (lua_pcall(L, n, 0, 0) != LUA_OK)
      l_message(progname, lua_pushfstring(L, "error calling 'print' (%s)",
                                             lua_tostring(L, -1)));
  }
}

static int lastmouse_x, lastmouse_y;

static void handle_key_event (lua_State *L) {
	int release = 0;
	if( key_event_scancode & 0x80) {
		release = 1;
		key_event_scancode = key_event_scancode & 0x7f;
	} 
	const char *keyname = scancode_to_name( key_event_scancode );
	lua_getglobal(L, "allegro");
	if( release ) lua_getfield(L, -1, "keyreleased");
	else		  lua_getfield(L, -1, "keypressed");
	lua_pushstring(L, keyname );
	lua_pcall(L, 1, 0, 0);
	lua_pop(L, 1);
	
	key_event = 0;
}

static void handle_mouse_event (lua_State *L) {
	
	int mouse_n;
	mouse_event = 0;

	if( mouse_event_flags & MOUSE_FLAG_MOVE ) {
		lua_getglobal(L, "allegro");
		lua_getfield(L, -1, "mousemoved");
		lua_pushinteger(L, mouse_x );
		lua_pushinteger(L, mouse_y );
		lua_pushinteger(L, mouse_x - lastmouse_x );
		lua_pushinteger(L, mouse_y - lastmouse_y );
		lua_pcall(L, 4, 0, 0);
		lua_pop(L, 1);
		lastmouse_x = mouse_x;
		lastmouse_y = mouse_y;
		return;
	}
	if( mouse_event_flags & (MOUSE_FLAG_LEFT_DOWN | MOUSE_FLAG_LEFT_UP )) mouse_n = 1;
	if( mouse_event_flags & (MOUSE_FLAG_RIGHT_DOWN | MOUSE_FLAG_RIGHT_UP )) mouse_n = 2;
	if( mouse_event_flags & (MOUSE_FLAG_MIDDLE_DOWN | MOUSE_FLAG_MIDDLE_UP )) mouse_n = 3;
	if( mouse_event_flags & (MOUSE_FLAG_LEFT_DOWN | MOUSE_FLAG_RIGHT_DOWN | MOUSE_FLAG_MIDDLE_DOWN)) {
		lua_getglobal(L, "allegro");
		lua_getfield(L, -1, "mousepressed");
		lua_pushinteger(L, mouse_x );
		lua_pushinteger(L, mouse_y );
		lua_pushinteger(L, mouse_n );
		lua_pcall(L, 3, 0, 0);
		lua_pop(L, 1);
		return;		
	}
	if( mouse_event_flags & (MOUSE_FLAG_LEFT_UP | MOUSE_FLAG_RIGHT_UP | MOUSE_FLAG_MIDDLE_UP)) {
		lua_getglobal(L, "allegro");
		lua_getfield(L, -1, "mousereleased");
		lua_pushinteger(L, mouse_x );
		lua_pushinteger(L, mouse_y );
		lua_pushinteger(L, mouse_n );
		lua_pcall(L, 3, 0, 0);
		lua_pop(L, 1);
		return;		
	}
	//if( mouse_event_flag & MOUSE_FLAG_MOVE_Z ) { }
}

/*
** Main body of stand-alone interpreter (to be called in protected mode).
** Reads the options and handles them all.
*/
static int pmain (lua_State *L) {
  int ret, n = 0;
  char *eoption = NULL;
  int argc = (int)lua_tointeger(L, 1);
  char **argv = (char **)lua_touserdata(L, 2);
  if (n < argc && argv[n] && argv[n][0]) progname = argv[n++];
  if (n < argc && argv[n] && argv[n][0] == '-' && argv[n][1] == 'e') {  
	if (++n < argc && argv[n] && argv[n][0]) eoption = argv[n++];
  }
  if (n < argc && argv[n] && argv[n][0]) scriptname = argv[n];

  luaL_openlibs(L);  /* open standard libraries */
  createargtable(L, argv, argc, 1);
  createAllegrotable(L);
  if( eoption )
	  dostring(L, eoption, "-e option");
  
  dofile(L, scriptname );
  
  lua_getglobal(L, "allegro");
  lua_getfield(L, -1, "load");
  lua_getglobal(L, "args");
  ret = docall(L, 1, 0);
  if( ret ) {
    fprintf(stderr, "error calling load: %s\n", lua_tostring(L, -1) );
    lua_pushboolean(L, 0);  /* signal error */
  }

  set_color_depth(24);
  color = makecol(255,255,255);
  bgcolor = makecol(0,0,0);
  display = create_bitmap( screenX, screenY );
  
  set_gfx_mode(GFX_AUTODETECT_WINDOWED, screenX, screenY, 0, 0);

  lastmouse_x = mouse_x;
  lastmouse_y = mouse_y;
  int id;
  
  while( run_flag ) {
	  
    if( key_event ) handle_key_event(L);
	if( mouse_event ) handle_mouse_event(L);

    lua_getglobal(L, "allegro");
	lua_getfield(L, -1, "update");
    //docall(L, 0, 0);
	ret = lua_pcall(L, 0, 0, 0);
	if( ret ) {
		id = 1;
		break;
	}
	lua_pop(L, 1);
	
    lua_getglobal(L, "allegro");
	lua_getfield(L, -1, "draw");
    //docall(L, 0, 0);
	ret = lua_pcall(L, 0, 0, 0);
	if( ret ) {
		id = 2;
		break;
	}
	lua_pop(L, 1);
	
	show_mouse(display);
	blit( display, screen, 0, 0, 0, 0, screenX, screenY );
	//show_mouse(screen);
	clear_to_color( display, makecol(0,0,0) );	
  }
  
  destroy_bitmap( display );
  allegro_exit();
  
  if( ret ) {
    if( id == 1) 
		fprintf(stderr, "error calling update: %s\n", lua_tostring(L, -1) );
	else
		fprintf(stderr, "error calling draw: %s\n", lua_tostring(L, -1) );	
	lua_pushboolean(L, 0);  /* signal error */
  }
  else
    lua_pushboolean(L, 1);  /* signal no errors */
  return 1;
}


int main (int argc, char **argv) {
  int status, result;

  keyboard_lowlevel_callback = keyboard_handler;
  mouse_callback = mouse_handler;
  allegro_init();
  install_keyboard();
  install_mouse();
  install_timer();
  result = install_sound(DIGI_ALSA, MIDI_DIGMID, "");
  if( result ) 
	  fprintf(stderr, "install sound failure: %s\n", allegro_error );
  
  lua_State *L = luaL_newstate();  /* create state */
  if (L == NULL) {
    l_message(argv[0], "cannot create state: not enough memory");
    return EXIT_FAILURE;
  }
  lua_pushcfunction(L, &pmain);  /* to call 'pmain' in protected mode */
  lua_pushinteger(L, argc);  /* 1st argument */
  lua_pushlightuserdata(L, argv); /* 2nd argument */
  status = lua_pcall(L, 2, 1, 0);  /* do the call */
  result = lua_toboolean(L, -1);  /* get result */
  report(L, status);
  lua_close(L);
  return (result && status == LUA_OK) ? EXIT_SUCCESS : EXIT_FAILURE;
}

